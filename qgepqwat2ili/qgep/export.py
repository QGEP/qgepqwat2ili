import warnings
import xml.etree.ElementTree as ET

from geoalchemy2 import Geometry
from geoalchemy2.functions import ST_Force2D
from osgeo import ogr
from sqlalchemy import or_
from sqlalchemy.orm import Session

from .. import utils
from ..utils import future  # NOQA
from ..utils.various import logger
from .model_qgep import get_qgep_model

# We monkeymatch the GeoAlchemy's as_binary operator to use ST_AsBinary instead of
# ST_AsEWKT since we are loading the WKB with ogr instead of shapely (as the latter
# doesnt load curved geometries)
Geometry.as_binary = "ST_AsBinary"


def Element(*args):
    return ET.Element(*args)


def SubElement(*args):
    return ET.SubElement(*args)


def SubElementTxt(parent, tag, text):
    element = ET.SubElement(parent, tag)
    if text is not None:
        element.text = str(text)
    return element


def SubElementRef(parent, tag, ref):
    attrs = {"REF": ref} if ref is not None else {}
    element = ET.SubElement(parent, tag, attrs)
    return element


def SubElementGeo(parent, tag, wkb_element):
    element = ET.SubElement(parent, tag)
    if wkb_element is not None:
        # TODO : properly load geometry types
        surface = ET.SubElement(element, "SURFACE")
        boundary = ET.SubElement(surface, "BOUNDARY")
        polyline = ET.SubElement(boundary, "POLYLINE")

        geom = ogr.CreateGeometryFromWkb(wkb_element.data.tobytes())
        if geom is None:
            polyline.insert(0, ET.Comment("Could not parse WKB"))
            return

        for part in geom:
            for p in part.GetPoints():
                coord = ET.SubElement(polyline, "COORD")
                SubElementTxt(coord, "C1", p[0])
                SubElementTxt(coord, "C2", p[1])
    return element


def qgep_export(output_path, downstream_of=None, upstream_of=None):
    """
    Export data from the QGEP model into the ili2pg model.
    Args:
        output_path:    output file
        downstream_of:  if provided, limits the export to nodes that are downstream of the provided node
        upstream_of:    if provided, limits the export to nodes that are upstream of the provided node
    """

    transfer = Element("TRANSFER", {"xmlns": "http://www.interlis.ch/INTERLIS2.3"})

    # HEADER
    headersection = SubElement(transfer, "HEADERSECTION", {"VERSION": "2.3", "SENDER": "VSA"})
    models = SubElement(headersection, "MODELS")
    SubElement(
        models, "MODEL", {"NAME": "VSA_KEK_2019_LV95", "VERSION": "20.01.2021", "URI": "http://www.vsa.ch/models"}
    )
    SubElement(
        models,
        "MODEL",
        {"NAME": "SIA405_ABWASSER_2015_LV95", "VERSION": "17.04.2018", "URI": "http://www.sia.ch/405"},
    )
    SubElement(
        models, "MODEL", {"NAME": "SIA405_Base_LV95", "VERSION": "05.10.2018", "URI": "http://www.interlis.ch/models"}
    )
    SubElement(
        models, "MODEL", {"NAME": "Base_LV95", "VERSION": "05.10.2018", "URI": "http://www.interlis.ch/models"}
    )
    alias = SubElement(headersection, "ALIAS")
    SubElement(alias, "ENTRIES", {"FOR": "VSA_KEK_2019_LV95"})
    SubElementTxt(headersection, "COMMENT", "Dataset Generated by QGEP")

    # DATA
    datasection = SubElement(transfer, "DATASECTION")

    QGEP = get_qgep_model()

    # Logging disabled (very slow)
    # qgep_session = Session(utils.sqlalchemy.create_engine(logger_name="qgep"), autocommit=False, autoflush=False)
    qgep_session = Session(utils.sqlalchemy.create_engine(), autocommit=False, autoflush=False)

    # Upstream/Downstream filtering
    subset_ids = None
    if upstream_of or downstream_of:

        common_table_expressions = []
        params = {}
        select_clauses = []
        if upstream_of:
            common_table_expressions.append(
                """
                node_with_child AS (
                    SELECT n.id, s.to_node AS child_id, n.ne_id FROM qgep_network.node n
                    LEFT JOIN qgep_network.segment s ON s.from_node = n.id
                ),
                upstream AS (
                    SELECT id, child_id, ne_id
                    FROM node_with_child
                    WHERE ne_id = :upstream_of

                    UNION ALL

                    SELECT n.id, n.child_id, n.ne_id
                    FROM node_with_child n
                    INNER JOIN upstream ON upstream.id = n.child_id
                )
            """
            )
            select_clauses.append("SELECT ne_id FROM upstream")
            params["upstream_of"] = upstream_of

        if downstream_of:
            common_table_expressions.append(
                """
                node_with_parent AS (
                    SELECT n.id, s.from_node AS parent_id, n.ne_id FROM qgep_network.node n
                    LEFT JOIN qgep_network.segment s ON s.to_node = n.id
                ),
                downstream AS (
                    SELECT id, parent_id, ne_id
                    FROM node_with_parent
                    WHERE ne_id = :downstream_of

                    UNION ALL

                    SELECT n.id, n.parent_id, n.ne_id
                    FROM node_with_parent n
                    INNER JOIN downstream ON downstream.id = n.parent_id
                )
            """
            )
            select_clauses.append("SELECT ne_id FROM downstream")
            params["downstream_of"] = downstream_of

        subset_query = f"WITH RECURSIVE {','.join(common_table_expressions)} {' INTERSECT '.join(select_clauses)};"

        rows = qgep_session.execute(subset_query, params)
        subset_ids = list(row[0] for row in rows)

    def get_vl(relation):
        """
        Gets a literal value from a value list relation
        """
        if relation is None:
            return None
        return relation.value_de

    def create_basket(basket_name):
        return SubElement(datasection, basket_name, {"BID": "fk11abk6w70lrfnh", "KIND": "UPDATE"})

    def create_node(row, basket, node_name):
        node = SubElement(basket, f"{basket.tag}.{node_name}", {"TID": row.obj_id})

        SubElementTxt(node, "OBJ_ID", row.obj_id)

        # metaattributes
        metaattribute = SubElement(node, "Metaattribute")
        metaattribute_sia = SubElement(metaattribute, "SIA405_Base_LV95.Metaattribute")
        SubElementTxt(metaattribute_sia, "Datenherr", getattr(row.fk_dataowner__REL, "name", "unknown"))
        SubElementTxt(metaattribute_sia, "Datenlieferant", getattr(row.fk_provider__REL, "name", "unknown"))
        SubElementTxt(metaattribute_sia, "Letzte_Aenderung", row.last_modification.strftime("%Y%m%d"))

        return node

    def wastewater_structure_common(row, node):
        """
        Returns common attributes for wastewater_structure
        """
        warnings.warn("Mapping of wastewater_structure->abwasserbauwerk is not fully implemented.")
        # SubElementTxt(node, 'Akten', row.REPLACE_ME)  # TODO : not sure, is it contract_section or records ?
        SubElementTxt(node, "Status", get_vl(row.status__REL))
        SubElementTxt(node, "Baujahr", row.year_of_construction)
        SubElementTxt(node, "BaulicherZustand", get_vl(row.structure_condition__REL))
        # SubElementTxt(node, 'Baulos', row.REPLACE_ME)  # TODO : not sure, is it contract_section or records ?
        SubElementTxt(node, "Bemerkung", row.remark)
        SubElementRef(node, "BetreiberRef", row.fk_operator)
        SubElementTxt(node, "Bezeichnung", row.identifier)
        SubElementTxt(node, "Bruttokosten", row.gross_costs)
        SubElementGeo(node, "Detailgeometrie", row.detail_geometry_geometry)
        SubElementRef(node, "EigentuemerRef", row.fk_owner)
        SubElementTxt(node, "Ersatzjahr", row.year_of_replacement)
        SubElementTxt(node, "Finanzierung", row.financing)
        SubElementTxt(node, "Inspektionsintervall", row.inspection_interval)
        SubElementTxt(node, "Sanierungsbedarf", get_vl(row.renovation_necessity__REL))
        SubElementTxt(node, "Standortname", row.location_name)
        SubElementTxt(node, "Subventionen", row.subsidies)
        SubElementTxt(node, "WBW_Basisjahr", row.rv_base_year)
        SubElementTxt(node, "WBW_Bauart", get_vl(row.rv_construction_type__REL))
        SubElementTxt(node, "Wiederbeschaffungswert", row.replacement_value)
        SubElementTxt(node, "Zugaenglichkeit", get_vl(row.accessibility__REL))

    def wastewater_network_element_common(row, node):
        """
        Returns common attributes for network_element
        """
        SubElementRef(node, "AbwasserbauwerkRef", row.fk_wastewater_structure)
        SubElementTxt(node, "Bemerkung", row.remark)
        SubElementTxt(node, "Bezeichnung", row.identifier)

    def structure_part_common(row):
        """
        Returns common attributes for structure_part
        """
        return {
            "abwasserbauwerkref": get_tid(row.fk_wastewater_structure__REL),
            "bemerkung": row.remark,
            "bezeichnung": row.identifier,
            "instandstellung": get_vl(row.renovation_demand__REL),
        }

    basket = create_basket("SIA405_ABWASSER_2015_LV95.SIA405_Abwasser")

    logger.info("Exporting QGEP.organisation -> ABWASSER.organisation, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.organisation)
    for row in query:

        # main
        node = create_node(row, basket, "Organisation")

        # content
        SubElementTxt(node, "Bemerkung", row.remark)
        SubElementTxt(node, "Bezeichnung", row.identifier)

        print(".", end="")
    logger.info("done")

    logger.info("Exporting QGEP.channel -> ABWASSER.kanal, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.channel)
    if subset_ids:
        query = query.join(QGEP.wastewater_networkelement).filter(
            QGEP.wastewater_networkelement.obj_id.in_(subset_ids)
        )
    for row in query:
        # main
        node = create_node(row, basket, "Kanal")
        # common
        wastewater_structure_common(row, node)
        # content
        SubElementTxt(node, "Bettung_Umhuellung", get_vl(row.bedding_encasement__REL))
        SubElementTxt(node, "FunktionHierarchisch", get_vl(row.function_hierarchic__REL))
        SubElementTxt(node, "FunktionHydraulisch", get_vl(row.function_hydraulic__REL))
        SubElementTxt(node, "Nutzungsart_geplant", get_vl(row.usage_planned__REL))
        SubElementTxt(node, "Nutzungsart_Ist", get_vl(row.usage_current__REL))
        SubElementTxt(node, "Rohrlaenge", row.pipe_length)
        SubElementTxt(node, "Spuelintervall", row.jetting_interval)
        SubElementTxt(node, "Verbindungsart", get_vl(row.connection_type__REL))

        print(".", end="")
    logger.info("done")

    logger.info("Exporting QGEP.manhole -> ABWASSER.normschacht, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.manhole)
    if subset_ids:
        query = query.join(QGEP.wastewater_networkelement).filter(
            QGEP.wastewater_networkelement.obj_id.in_(subset_ids)
        )
    for row in query:
        # main
        node = create_node(row, basket, "Normschacht")
        # common
        wastewater_structure_common(row, node)
        # content
        SubElementTxt(node, "Dimension1", row.dimension1)
        SubElementTxt(node, "Dimension2", row.dimension2)
        SubElementTxt(node, "Funktion", get_vl(row.function__REL))
        SubElementTxt(node, "Material", get_vl(row.material__REL))
        SubElementTxt(node, "Oberflaechenzulauf", get_vl(row.surface_inflow__REL))
        print(".", end="")
    logger.info("done")

    logger.info("Exporting QGEP.discharge_point -> ABWASSER.einleitstelle, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.discharge_point)
    if subset_ids:
        query = query.join(QGEP.wastewater_networkelement).filter(
            QGEP.wastewater_networkelement.obj_id.in_(subset_ids)
        )
    for row in query:
        # main
        node = create_node(row, basket, "Einleitstelle")
        # common
        wastewater_structure_common(row, node)
        # content
        SubElementTxt(node, "Hochwasserkote", row.highwater_level)
        SubElementTxt(node, "Relevanz", get_vl(row.relevance__REL))
        SubElementTxt(node, "Terrainkote", row.terrain_level)
        SubElementTxt(node, "Wasserspiegel_Hydraulik", row.waterlevel_hydraulic)
        print(".", end="")
    logger.info("done")

    logger.info("Exporting QGEP.special_structure -> ABWASSER.spezialbauwerk, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.special_structure)
    if subset_ids:
        query = query.join(QGEP.wastewater_networkelement).filter(
            QGEP.wastewater_networkelement.obj_id.in_(subset_ids)
        )
    for row in query:
        # main
        node = create_node(row, basket, "Spezialbauwerk")
        # common
        wastewater_structure_common(row, node)
        # content
        SubElementTxt(node, "Bypass", get_vl(row.bypass__REL))
        SubElementTxt(node, "Funktion", get_vl(row.relevance__REL))
        SubElementTxt(node, "Notueberlauf", get_vl(row.emergency_spillway__REL))
        SubElementTxt(node, "Regenbecken_Anordnung", get_vl(row.stormwater_tank_arrangement__REL))
        print(".", end="")
    logger.info("done")

    logger.info("Exporting QGEP.infiltration_installation -> ABWASSER.versickerungsanlage, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.infiltration_installation)
    if subset_ids:
        query = query.join(QGEP.wastewater_networkelement).filter(
            QGEP.wastewater_networkelement.obj_id.in_(subset_ids)
        )
    for row in query:
        # main
        node = create_node(row, basket, "Spezialbauwerk")
        # common
        wastewater_structure_common(row, node)
        # content
        SubElementTxt(node, "Art", get_vl(row.kind__REL))
        SubElementTxt(node, "Beschriftung", get_vl(row.labeling__REL))
        SubElementTxt(node, "Dimension1", row.dimension1)
        SubElementTxt(node, "Dimension2", row.dimension2)
        SubElementTxt(node, "Gwdistanz", row.distance_to_aquifer)
        SubElementTxt(node, "Maengel", get_vl(row.defects__REL))
        SubElementTxt(node, "Notueberlauf", get_vl(row.emergency_spillway__REL))
        SubElementTxt(node, "Saugwagen", get_vl(row.vehicle_access__REL))  # TODO : check mapping
        SubElementTxt(node, "Schluckvermoegen", row.absorption_capacity)  # TODO : check mapping
        SubElementTxt(node, "Versickerungswasser", get_vl(row.seepage_utilization__REL))  # TODO : check mapping
        SubElementTxt(node, "Wasserdichtheit", get_vl(row.watertightness__REL))
        SubElementTxt(node, "Wirksameflaeche", row.effective_area)
        print(".", end="")
    logger.info("done")

    logger.info("Exporting QGEP.pipe_profile -> ABWASSER.rohrprofil, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.pipe_profile)
    if subset_ids:
        query = query.join(QGEP.reach).filter(QGEP.wastewater_networkelement.obj_id.in_(subset_ids))
    for row in query:
        # main
        node = create_node(row, basket, "Rohrprofil")
        # content
        SubElementTxt(node, "Bemerkung", row.remark)
        SubElementTxt(node, "Bezeichnung", row.identifier)
        SubElementTxt(node, "HoehenBreitenverhaeltnis", row.height_width_ratio)
        SubElementTxt(node, "Profiltyp", get_vl(row.profile_type__REL))
        print(".", end="")
    logger.info("done")

    logger.info("Exporting QGEP.reach_point -> ABWASSER.haltungspunkt, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.reach_point)
    if subset_ids:
        query = query.join(
            QGEP.reach,
            or_(
                QGEP.reach_point.obj_id == QGEP.reach.fk_reach_point_from,
                QGEP.reach_point.obj_id == QGEP.reach.fk_reach_point_to,
            ),
        ).filter(QGEP.wastewater_networkelement.obj_id.in_(subset_ids))
    for row in query:
        # main
        node = create_node(row, basket, "Haltungspunkt")
        # content
        SubElementTxt(node, "AbwassernetzelementRef", row.fk_wastewater_networkelement)
        SubElementTxt(node, "Auslaufform", get_vl(row.outlet_shape__REL))
        SubElementTxt(node, "Bemerkung", row.remark)
        SubElementTxt(node, "Bezeichnung", row.identifier)
        SubElementTxt(node, "Hoehengenauigkeit", get_vl(row.elevation_accuracy__REL))
        SubElementTxt(node, "Kote", row.level)
        SubElementGeo(node, "Lage", ST_Force2D(row.situation_geometry))
        SubElementTxt(node, "Lage_Anschluss", row.position_of_connection)
        print(".", end="")
    logger.info("done")

    logger.info("Exporting QGEP.wastewater_node -> ABWASSER.abwasserknoten, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.wastewater_node)
    if subset_ids:
        query = query.filter(QGEP.wastewater_networkelement.obj_id.in_(subset_ids))
    for row in query:
        # main
        node = create_node(row, basket, "Abwasserknoten")
        # common
        wastewater_network_element_common(row, node)
        # content
        # TODO : WARNING : fk_hydr_geometry is not mapped
        SubElementTxt(node, "Lage", ST_Force2D(row.situation_geometry))
        SubElementTxt(node, "Rueckstaukote", row.backflow_level)
        SubElementTxt(node, "Sohlenkote", row.bottom_level)
        print(".", end="")
    logger.info("done")

    logger.info("Exporting QGEP.reach -> ABWASSER.haltung, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.reach)
    if subset_ids:
        query = query.filter(QGEP.wastewater_networkelement.obj_id.in_(subset_ids))
    for row in query:
        # main
        node = create_node(row, basket, "Haltung")
        # common
        wastewater_network_element_common(row, node)
        # content
        warnings.warn(
            f"QGEP field reach.elevation_determination has no equivalent in the interlis model. It will be ignored."
        )
        # NOT MAPPED : elevation_determination
        SubElementTxt(node, "Innenschutz", get_vl(row.inside_coating__REL))
        SubElementTxt(node, "LaengeEffektiv", row.length_effective)
        SubElementTxt(node, "Lagebestimmung", get_vl(row.horizontal_positioning__REL))
        SubElementTxt(node, "Lichte_Hoehe", row.clear_height)
        SubElementTxt(node, "Material", row.material)
        SubElementRef(node, "nachHaltungspunktRef", row.fk_reach_point_to)
        SubElementTxt(node, "Plangefaelle", row.slope_building_plan)  # TODO : check, does this need conversion ?
        SubElementTxt(node, "Reibungsbeiwert", row.coefficient_of_friction)
        SubElementTxt(node, "Reliner_Art", row.relining_kind)
        SubElementTxt(node, "Reliner_Bautechnik", row.relining_construction)
        SubElementTxt(node, "Reliner_Material", get_vl(row.reliner_material__REL))
        SubElementTxt(node, "Reliner_Nennweite", row.reliner_nominal_size)
        SubElementTxt(node, "Ringsteifigkeit", row.ring_stiffness)
        SubElementRef(node, "RohrprofilRef", row.fk_pipe_profile)
        SubElementGeo(node, "Verlauf", row.progression_geometry)
        SubElementRef(node, "vonHaltungspunktRef", row.fk_reach_point_from)
        SubElementTxt(node, "Wandrauhigkeit", row.wall_roughness)
        print(".", end="")
    logger.info("done")

    """

    logger.info("Exporting QGEP.dryweather_downspout -> ABWASSER.trockenwetterfallrohr, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.dryweather_downspout)
    if subset_ids:
        query = query.join(QGEP.wastewater_structure, QGEP.wastewater_networkelement).filter(
            QGEP.wastewater_networkelement.obj_id.in_(subset_ids)
        )
    for row in query:

        # AVAILABLE FIELDS IN QGEP.dryweather_downspout

        # --- structure_part ---
        # fk_dataowner, fk_provider, fk_wastewater_structure, identifier, last_modification, remark, renovation_demand

        # --- dryweather_downspout ---
        # diameter, obj_id

        # --- _bwrel_ ---
        # access_aid_kind__BWREL_obj_id, backflow_prevention__BWREL_obj_id, benching_kind__BWREL_obj_id, dryweather_flume_material__BWREL_obj_id, electric_equipment__BWREL_obj_id, electromechanical_equipment__BWREL_obj_id, solids_retention__BWREL_obj_id, tank_cleaning__BWREL_obj_id, tank_emptying__BWREL_obj_id

        # --- _rel_ ---
        # fk_dataowner__REL, fk_provider__REL, fk_wastewater_structure__REL, renovation_demand__REL

        trockenwetterfallrohr = ABWASSER.trockenwetterfallrohr(
            # FIELDS TO MAP TO ABWASSER.trockenwetterfallrohr

            # --- baseclass ---
            # --- sia405_baseclass ---
            **base_common(row, "trockenwetterfallrohr"),

            # --- bauwerksteil ---
            **structure_part_common(row),

            # --- trockenwetterfallrohr ---
            durchmesser=row.diameter,
        )
        abwasser_session.add(trockenwetterfallrohr)
        create_metaattributes(row)
        print(".", end="")
    logger.info("done")
    abwasser_session.flush()

    logger.info("Exporting QGEP.access_aid -> ABWASSER.einstiegshilfe, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.access_aid)
    if subset_ids:
        query = query.join(QGEP.wastewater_structure, QGEP.wastewater_networkelement).filter(
            QGEP.wastewater_networkelement.obj_id.in_(subset_ids)
        )
    for row in query:

        # AVAILABLE FIELDS IN QGEP.access_aid

        # --- structure_part ---
        # fk_dataowner, fk_provider, fk_wastewater_structure, identifier, last_modification, remark, renovation_demand

        # --- access_aid ---
        # kind, obj_id

        # --- _bwrel_ ---
        # access_aid_kind__BWREL_obj_id, backflow_prevention__BWREL_obj_id, benching_kind__BWREL_obj_id, dryweather_flume_material__BWREL_obj_id, electric_equipment__BWREL_obj_id, electromechanical_equipment__BWREL_obj_id, solids_retention__BWREL_obj_id, tank_cleaning__BWREL_obj_id, tank_emptying__BWREL_obj_id

        # --- _rel_ ---
        # fk_dataowner__REL, fk_provider__REL, fk_wastewater_structure__REL, kind__REL, renovation_demand__REL

        einstiegshilfe = ABWASSER.einstiegshilfe(
            # FIELDS TO MAP TO ABWASSER.einstiegshilfe

            # --- baseclass ---
            # --- sia405_baseclass ---
            **base_common(row, "einstiegshilfe"),

            # --- bauwerksteil ---
            **structure_part_common(row),

            # --- einstiegshilfe ---
            art=get_vl(row.kind__REL),
        )
        abwasser_session.add(einstiegshilfe)
        create_metaattributes(row)
        print(".", end="")
    logger.info("done")
    abwasser_session.flush()

    logger.info("Exporting QGEP.dryweather_flume -> ABWASSER.trockenwetterrinne, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.dryweather_flume)
    if subset_ids:
        query = query.join(QGEP.wastewater_structure, QGEP.wastewater_networkelement).filter(
            QGEP.wastewater_networkelement.obj_id.in_(subset_ids)
        )
    for row in query:

        # AVAILABLE FIELDS IN QGEP.dryweather_flume

        # --- structure_part ---
        # fk_dataowner, fk_provider, fk_wastewater_structure, identifier, last_modification, remark, renovation_demand

        # --- dryweather_flume ---
        # material, obj_id

        # --- _bwrel_ ---
        # access_aid_kind__BWREL_obj_id, backflow_prevention__BWREL_obj_id, benching_kind__BWREL_obj_id, dryweather_flume_material__BWREL_obj_id, electric_equipment__BWREL_obj_id, electromechanical_equipment__BWREL_obj_id, solids_retention__BWREL_obj_id, tank_cleaning__BWREL_obj_id, tank_emptying__BWREL_obj_id

        # --- _rel_ ---
        # fk_dataowner__REL, fk_provider__REL, fk_wastewater_structure__REL, material__REL, renovation_demand__REL

        trockenwetterrinne = ABWASSER.trockenwetterrinne(
            # FIELDS TO MAP TO ABWASSER.trockenwetterrinne

            # --- baseclass ---
            # --- sia405_baseclass ---
            **base_common(row, "trockenwetterrinne"),

            # --- bauwerksteil ---
            **structure_part_common(row),

            # --- trockenwetterrinne ---
            material=get_vl(row.material__REL),
        )
        abwasser_session.add(trockenwetterrinne)
        create_metaattributes(row)
        print(".", end="")
    logger.info("done")
    abwasser_session.flush()

    logger.info("Exporting QGEP.cover -> ABWASSER.deckel, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.cover)
    if subset_ids:
        query = query.join(QGEP.wastewater_structure, QGEP.wastewater_networkelement).filter(
            QGEP.wastewater_networkelement.obj_id.in_(subset_ids)
        )
    for row in query:

        # AVAILABLE FIELDS IN QGEP.cover

        # --- structure_part ---
        # fk_dataowner, fk_provider, fk_wastewater_structure, identifier, last_modification, remark, renovation_demand

        # --- cover ---
        # brand, cover_shape, diameter, fastening, level, material, obj_id, positional_accuracy, situation_geometry, sludge_bucket, venting

        # --- _bwrel_ ---
        # access_aid_kind__BWREL_obj_id, backflow_prevention__BWREL_obj_id, benching_kind__BWREL_obj_id, dryweather_flume_material__BWREL_obj_id, electric_equipment__BWREL_obj_id, electromechanical_equipment__BWREL_obj_id, solids_retention__BWREL_obj_id, tank_cleaning__BWREL_obj_id, tank_emptying__BWREL_obj_id, wastewater_structure__BWREL_fk_main_cover

        # --- _rel_ ---
        # cover_shape__REL, fastening__REL, fk_dataowner__REL, fk_provider__REL, fk_wastewater_structure__REL, material__REL, positional_accuracy__REL, renovation_demand__REL, sludge_bucket__REL, venting__REL

        deckel = ABWASSER.deckel(
            # FIELDS TO MAP TO ABWASSER.deckel

            # --- baseclass ---
            # --- sia405_baseclass ---
            **base_common(row, "deckel"),

            # --- bauwerksteil ---
            **structure_part_common(row),

            # --- deckel ---
            deckelform=get_vl(row.cover_shape__REL),
            durchmesser=row.diameter,
            entlueftung=get_vl(row.venting__REL),
            fabrikat=row.brand,
            kote=row.level,
            lage=ST_Force2D(row.situation_geometry),
            lagegenauigkeit=get_vl(row.positional_accuracy__REL),
            material=get_vl(row.material__REL),
            schlammeimer=get_vl(row.sludge_bucket__REL),
            verschluss=get_vl(row.fastening__REL),
        )
        abwasser_session.add(deckel)
        create_metaattributes(row)
        print(".", end="")
    logger.info("done")
    abwasser_session.flush()

    logger.info("Exporting QGEP.benching -> ABWASSER.bankett, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.benching)
    if subset_ids:
        query = query.join(QGEP.wastewater_structure, QGEP.wastewater_networkelement).filter(
            QGEP.wastewater_networkelement.obj_id.in_(subset_ids)
        )
    for row in query:

        # AVAILABLE FIELDS IN QGEP.benching

        # --- structure_part ---
        # fk_dataowner, fk_provider, fk_wastewater_structure, identifier, last_modification, remark, renovation_demand

        # --- benching ---
        # kind, obj_id

        # --- _bwrel_ ---
        # access_aid_kind__BWREL_obj_id, backflow_prevention__BWREL_obj_id, benching_kind__BWREL_obj_id, dryweather_flume_material__BWREL_obj_id, electric_equipment__BWREL_obj_id, electromechanical_equipment__BWREL_obj_id, solids_retention__BWREL_obj_id, tank_cleaning__BWREL_obj_id, tank_emptying__BWREL_obj_id

        # --- _rel_ ---
        # fk_dataowner__REL, fk_provider__REL, fk_wastewater_structure__REL, kind__REL, renovation_demand__REL

        bankett = ABWASSER.bankett(
            # FIELDS TO MAP TO ABWASSER.bankett

            # --- baseclass ---
            # --- sia405_baseclass ---
            **base_common(row, "bankett"),

            # --- sia405_baseclass ---
            obj_id=row.obj_id,

            # --- bauwerksteil ---
            **structure_part_common(row),

            # --- bankett ---
            art=get_vl(row.kind__REL),
        )
        abwasser_session.add(bankett)
        create_metaattributes(row)
        print(".", end="")
    logger.info("done")
    abwasser_session.flush()
    """

    basket = create_basket("VSA_KEK_2019_LV95.KEK")

    logger.info("Exporting QGEP.examination -> ABWASSER.untersuchung, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.examination)
    if subset_ids:
        query = (
            query.join(QGEP.reach_point)
            .join(QGEP.reach, QGEP.reach_point.fk_wastewater_networkelement == QGEP.reach.obj_id)
            .filter(QGEP.wastewater_networkelement.obj_id.in_(subset_ids))
        )
    for row in query:

        # main
        node = create_node(row, basket, "Untersuchung")

        warnings.warn(
            "QGEP field maintenance_event.active_zone has no equivalent in the interlis model. It will be ignored."
        )

        # --- erhaltungsereignis ---
        # SubElementTxt(node, 'Abwasserbauwerkref', row.REPLACE_ME)  # TODO : convert this to M2N relation through re_maintenance_event_wastewater_structure
        SubElementTxt(node, "Art", row.kind)
        SubElementTxt(node, "Status", row.status)
        SubElementRef(node, "Ausfuehrende_FirmaRef", row.fk_operating_company)
        SubElementTxt(node, "Ausfuehrender", row.operator)
        SubElementTxt(node, "Bemerkung", row.remark)
        SubElementTxt(node, "Bezeichnung", row.identifier)
        SubElementTxt(node, "Datengrundlage", row.base_data)
        SubElementTxt(node, "Dauer", row.duration)
        SubElementTxt(node, "Detaildaten", row.data_details)
        SubElementTxt(node, "Ergebnis", row.result)
        SubElementTxt(node, "Grund", row.reason)
        SubElementTxt(node, "Kosten", row.cost)
        SubElementTxt(node, "Zeitpunkt", row.time_point)

        # --- untersuchung ---
        SubElementTxt(node, "Bispunktbezeichnung", row.to_point_identifier)
        SubElementTxt(node, "Erfassungsart", row.recording_type)
        SubElementTxt(node, "Fahrzeug", row.vehicle)
        SubElementTxt(node, "Geraet", row.equipment)
        SubElementTxt(node, "Haltungspunktref", row.fk_reach_point)
        SubElementTxt(node, "Inspizierte_laenge", row.inspected_length)
        SubElementTxt(node, "Videonummer", row.videonumber)
        SubElementTxt(node, "Vonpunktbezeichnung", row.from_point_identifier)
        SubElementTxt(node, "Witterung", row.weather)

        print(".", end="")
    logger.info("done")

    """

    logger.info("Exporting QGEP.damage_manhole -> ABWASSER.normschachtschaden, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.damage_manhole)
    if subset_ids:
        query = query.join(QGEP.examination, QGEP.reach_point, QGEP.wastewater_networkelement).filter(
            QGEP.wastewater_networkelement.obj_id.in_(subset_ids)
        )
    for row in query:

        # AVAILABLE FIELDS IN QGEP.damage_manhole

        # --- damage ---

        # --- damage_manhole ---
        # manhole_damage_code, manhole_shaft_area, obj_id

        # --- _bwrel_ ---
        # damage_channel_channel_damage_code__BWREL_obj_id

        # --- _rel_ ---
        # connection__REL, fk_dataowner__REL, fk_examination__REL, fk_provider__REL, manhole_damage_code__REL, manhole_shaft_area__REL, single_damage_class__REL

        normschachtschaden = ABWASSER.normschachtschaden(
            # FIELDS TO MAP TO ABWASSER.normschachtschaden

            # --- baseclass ---
            # --- sia405_baseclass ---
            **base_common(row, "normschachtschaden"),

            # --- schaden ---
            anmerkung=row.comments,
            ansichtsparameter=row.view_parameters,
            einzelschadenklasse=get_vl(row.single_damage_class__REL),
            streckenschaden=row.damage_reach,
            untersuchungref=get_tid(row.fk_examination__REL),
            verbindung=get_vl(row.connection__REL),
            videozaehlerstand=row.video_counter,

            # --- normschachtschaden ---
            distanz=row.distance,
            quantifizierung1=row.quantification1,
            quantifizierung2=row.quantification2,
            schachtbereich=get_vl(row.manhole_shaft_area__REL),
            schachtschadencode=get_vl(row.manhole_damage_code__REL),
            schadenlageanfang=row.damage_begin,
            schadenlageende=row.damage_end,
        )
        abwasser_session.add(normschachtschaden)
        create_metaattributes(row)
        print(".", end="")
    logger.info("done")
    abwasser_session.flush()

    logger.info("Exporting QGEP.damage_channel -> ABWASSER.kanalschaden, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.damage_channel)
    if subset_ids:
        query = (
            query.join(QGEP.examination)
            .join(QGEP.reach_point)
            .join(QGEP.wastewater_networkelement)
            .filter(QGEP.wastewater_networkelement.obj_id.in_(subset_ids))
        )
    for row in query:

        # AVAILABLE FIELDS IN QGEP.damage_channel

        # --- damage ---
        # comments, connection, damage_begin, damage_end, damage_reach, distance, fk_dataowner, fk_examination, fk_provider, last_modification, quantification1, quantification2, single_damage_class, video_counter, view_parameters

        # --- damage_channel ---
        # , obj_id

        # --- _bwrel_ ---
        # damage_channel_channel_damage_code__BWREL_obj_id

        # --- _rel_ ---
        # channel_damage_code__REL, connection__REL, fk_dataowner__REL, fk_examination__REL, fk_provider__REL, single_damage_class__REL

        kanalschaden = ABWASSER.kanalschaden(
            # FIELDS TO MAP TO ABWASSER.kanalschaden

            # --- baseclass ---
            # --- sia405_baseclass ---
            **base_common(row, "kanalschaden"),

            # --- schaden ---
            anmerkung=row.comments,
            ansichtsparameter=row.view_parameters,
            einzelschadenklasse=get_vl(row.single_damage_class__REL),
            streckenschaden=row.damage_reach,
            untersuchungref=get_tid(row.fk_examination__REL),
            verbindung=get_vl(row.connection__REL),
            videozaehlerstand=row.video_counter,

            # --- kanalschaden ---
            distanz=row.distance,
            kanalschadencode=get_vl(row.channel_damage_code__REL),
            quantifizierung1=row.quantification1,
            quantifizierung2=row.quantification2,
            schadenlageanfang=row.damage_begin,
            schadenlageende=row.damage_end,
        )
        abwasser_session.add(kanalschaden)
        create_metaattributes(row)
        print(".", end="")
    logger.info("done")
    abwasser_session.flush()

    logger.info("Exporting QGEP.data_media -> ABWASSER.datentraeger, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.data_media)
    for row in query:

        # AVAILABLE FIELDS IN QGEP.data_media

        # --- data_media ---
        # fk_dataowner, fk_provider, identifier, kind, last_modification, location, obj_id, path, remark

        # --- _rel_ ---
        # fk_dataowner__REL, fk_provider__REL, kind__REL

        datentraeger = ABWASSER.datentraeger(
            # FIELDS TO MAP TO ABWASSER.datentraeger

            # --- baseclass ---
            # --- sia405_baseclass ---
            **base_common(row, "datentraeger"),

            # --- datentraeger ---
            art=row.kind,
            bemerkung=row.remark,
            bezeichnung=row.identifier,
            pfad=row.path,
            standort=row.location,
        )
        abwasser_session.add(datentraeger)
        create_metaattributes(row)
        print(".", end="")
    logger.info("done")
    abwasser_session.flush()

    logger.info("Exporting QGEP.file -> ABWASSER.datei, ABWASSER.metaattribute")
    query = qgep_session.query(QGEP.file)
    for row in query:

        # AVAILABLE FIELDS IN QGEP.file

        # --- file ---
        # class, fk_data_media, fk_dataowner, fk_provider, identifier, kind, last_modification, obj_id, object, path_relative, remark

        # --- _rel_ ---
        # class__REL, fk_dataowner__REL, fk_provider__REL, kind__REL

        # NOTE: QGEP misses a FK to data_media, so we inject it manually here
        row.data_media__REL = qgep_session.query(QGEP.data_media).get(row.fk_data_media)

        datei = ABWASSER.datei(
            # FIELDS TO MAP TO ABWASSER.datei

            # --- baseclass ---
            # --- sia405_baseclass ---
            **base_common(row, "datei"),

            # --- datei ---
            art=get_vl(row.kind__REL) or '???',
            bemerkung=row.remark,
            bezeichnung=row.identifier,
            datentraegerref=get_tid(row.data_media__REL),
            klasse=getattr(row, "class"),  # class is a python keyword, this is equivalent to `klasse=row.class`,
            objekt=row.object,
            relativpfad=row.path_relative,
        )
        abwasser_session.add(datei)
        create_metaattributes(row)
        print(".", end="")
    logger.info("done")
    abwasser_session.flush()

    abwasser_session.commit()

    qgep_session.close()
    abwasser_session.close()
    """

    with open(output_path, "wb") as output_file:
        ET.indent(transfer)
        ET.ElementTree(transfer).write(output_file, encoding="UTF-8", xml_declaration=True)
